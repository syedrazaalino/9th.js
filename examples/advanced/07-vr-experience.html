<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Virtual Reality Experience</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #canvas { display: block; width: 100vw; height: 100vh; }
        #vr-button {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            z-index: 1000; padding: 15px 30px; background: #1e88e5; color: white;
            border: none; border-radius: 8px; font-size: 16px; font-weight: bold;
            cursor: pointer; transition: all 0.3s;
        }
        #vr-button:hover { background: #1976d2; transform: translateX(-50%) translateY(-2px); }
        #vr-button:disabled { background: #666; cursor: not-allowed; transform: translateX(-50%); }
        #vr-info {
            position: absolute; top: 20px; left: 20px; z-index: 1000;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            color: white; font-size: 14px; max-width: 300px;
        }
        #controls-info {
            position: absolute; top: 20px; right: 20px; z-index: 1000;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            color: white; font-size: 12px; max-width: 250px;
        }
        .vr-instruction {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; text-align: center; z-index: 999;
            background: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="vr-info">
        <h3>üåü VR Experience</h3>
        <div>Status: <span id="vr-status">Ready</span></div>
        <div>Mode: <span id="vr-mode">Desktop</span></div>
        <div>Controllers: <span id="controller-count">0</span></div>
        <div>Session: <span id="session-time">0.0</span>s</div>
    </div>
    
    <div id="controls-info">
        <h4>üéÆ VR Controls</h4>
        <div>Trigger: Interact with objects</div>
        <div>Grip: Grab and move objects</div>
        <div>Thumbstick: Move around</div>
        <div>Desktop: WASD + Mouse</div>
    </div>
    
    <button id="vr-button">üöÄ Enter VR</button>
    
    <div class="vr-instruction" id="vr-instruction">
        <div>Put on your VR headset</div>
        <div>Use controllers to interact</div>
    </div>
    
    <script src="../../src/index.js"></script>
    <script>
        class VRExperience {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.scene = new Engine.Scene();
                this.camera = new Engine.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.renderer = new Engine.WebGLRenderer({ canvas: this.canvas, gl: this.gl });
                
                // VR state
                this.isVRSupported = false;
                this.isVRActive = false;
                this.vrSession = null;
                this.vrSpace = null;
                this.controllers = [];
                this.sessionStartTime = 0;
                
                // Desktop controls
                this.camera.position.set(0, 1.6, 5);
                this.keys = {};
                this.mouseSensitivity = 0.002;
                this.movementSpeed = 5;
                
                // VR scene objects
                this.interactiveObjects = [];
                this.grabbedObject = null;
                
                this.setupLighting();
                this.setupScene();
                this.setupControls();
                this.checkVRSupport();
                
                this.animate();
            }
            
            setupLighting() {
                const ambientLight = new Engine.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new Engine.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // VR environment lighting
                const environmentLight = new Engine.HemisphereLight(0x87ceeb, 0x8B4513, 0.3);
                this.scene.add(environmentLight);
            }
            
            setupScene() {
                // VR Room environment
                this.createVRRoom();
                
                // Interactive objects
                this.createInteractiveObjects();
                
                // Particle system for ambiance
                this.createAmbientParticles();
                
                // 3D UI panels
                this.createVRPanels();
            }
            
            createVRRoom() {
                // Floor
                const floorGeometry = new Engine.PlaneGeometry(20, 20);
                const floorMaterial = new Engine.MeshLambertMaterial({
                    color: 0x2c3e50,
                    transparent: true,
                    opacity: 0.8
                });
                const floor = new Engine.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Walls
                const wallGeometry = new Engine.PlaneGeometry(20, 10);
                const wallMaterial = new Engine.MeshLambertMaterial({
                    color: 0x34495e,
                    transparent: true,
                    opacity: 0.9
                });
                
                const wall1 = new Engine.Mesh(wallGeometry, wallMaterial);
                wall1.position.set(0, 5, -10);
                this.scene.add(wall1);
                
                const wall2 = new Engine.Mesh(wallGeometry, wallMaterial);
                wall2.rotation.y = Math.PI / 2;
                wall2.position.set(-10, 5, 0);
                this.scene.add(wall2);
                
                // Decorative objects
                this.createFloatingCubes();
                this.createHolographicDisplays();
            }
            
            createInteractiveObjects() {
                // Physics objects
                for (let i = 0; i < 10; i++) {
                    const geometry = new Engine.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new Engine.MeshLambertMaterial({
                        color: Math.random() * 0xffffff
                    });
                    const cube = new Engine.Mesh(geometry, material);
                    
                    cube.position.set(
                        (Math.random() - 0.5) * 8,
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 8
                    );
                    
                    cube.userData = {
                        velocity: new Engine.Vector3(),
                        grabbed: false,
                        originalPosition: cube.position.clone()
                    };
                    
                    this.interactiveObjects.push(cube);
                    this.scene.add(cube);
                }
                
                // Spheres with special properties
                for (let i = 0; i < 5; i++) {
                    const geometry = new Engine.SphereGeometry(0.15, 16, 8);
                    const material = new Engine.MeshLambertMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const sphere = new Engine.Mesh(geometry, material);
                    
                    sphere.position.set(
                        (Math.random() - 0.5) * 8,
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 8
                    );
                    
                    sphere.userData = {
                        velocity: new Engine.Vector3(),
                        grabbed: false,
                        type: 'hologram',
                        originalPosition: sphere.position.clone()
                    };
                    
                    this.interactiveObjects.push(sphere);
                    this.scene.add(sphere);
                }
            }
            
            createFloatingCubes() {
                for (let i = 0; i < 15; i++) {
                    const geometry = new Engine.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new Engine.MeshLambertMaterial({
                        color: Math.random() * 0xffffff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const cube = new Engine.Mesh(geometry, material);
                    
                    cube.position.set(
                        (Math.random() - 0.5) * 15,
                        Math.random() * 8 + 2,
                        (Math.random() - 0.5) * 15
                    );
                    
                    cube.userData = {
                        originalPosition: cube.position.clone(),
                        rotationSpeed: new Engine.Vector3(
                            Math.random() * 0.02,
                            Math.random() * 0.02,
                            Math.random() * 0.02
                        )
                    };
                    
                    this.scene.add(cube);
                }
            }
            
            createHolographicDisplays() {
                // Create floating display panels
                for (let i = 0; i < 3; i++) {
                    const geometry = new Engine.PlaneGeometry(2, 1);
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Draw pattern
                    ctx.fillStyle = '#001122';
                    ctx.fillRect(0, 0, 512, 256);
                    ctx.fillStyle = '#00ffff';
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`DISPLAY ${i + 1}`, 256, 128);
                    
                    const texture = new Engine.CanvasTexture(canvas);
                    const material = new Engine.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const panel = new Engine.Mesh(geometry, material);
                    panel.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 4 + 2,
                        (Math.random() - 0.5) * 10
                    );
                    
                    this.scene.add(panel);
                }
            }
            
            createAmbientParticles() {
                for (let i = 0; i < 100; i++) {
                    const geometry = new Engine.SphereGeometry(0.02, 4, 2);
                    const material = new Engine.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.5
                    });
                    const particle = new Engine.Mesh(geometry, material);
                    
                    particle.position.set(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 10 + 1,
                        (Math.random() - 0.5) * 20
                    );
                    
                    particle.userData = {
                        velocity: new Engine.Vector3(
                            (Math.random() - 0.5) * 0.01,
                            0,
                            (Math.random() - 0.5) * 0.01
                        )
                    };
                    
                    this.scene.add(particle);
                }
            }
            
            createVRPanels() {
                // Main menu panel
                const geometry = new Engine.PlaneGeometry(1.5, 0.8);
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#001122';
                ctx.fillRect(0, 0, 512, 256);
                ctx.fillStyle = '#00ffff';
                ctx.font = '36px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('VR EXPERIENCE', 256, 80);
                ctx.font = '24px Arial';
                ctx.fillText('Interact with objects', 256, 140);
                ctx.fillText('Grab and throw cubes', 256, 180);
                
                const texture = new Engine.CanvasTexture(canvas);
                const material = new Engine.MeshBasicMaterial({
                    map: texture,
                    transparent: true
                });
                
                const panel = new Engine.Mesh(geometry, material);
                panel.position.set(0, 2, -3);
                
                this.scene.add(panel);
            }
            
            setupControls() {
                // Desktop controls
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                this.canvas.addEventListener('click', () => {
                    this.canvas.requestPointerLock();
                });
                
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement === this.canvas) {
                        document.addEventListener('mousemove', this.onMouseMove.bind(this));
                    } else {
                        document.removeEventListener('mousemove', this.onMouseMove.bind(this));
                    }
                });
                
                // VR button
                document.getElementById('vr-button').addEventListener('click', () => {
                    this.startVR();
                });
            }
            
            onMouseMove(event) {
                if (!this.isVRActive) {
                    this.camera.rotation.y -= event.movementX * this.mouseSensitivity;
                    this.camera.rotation.x -= event.movementY * this.mouseSensitivity;
                    this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));
                }
            }
            
            async checkVRSupport() {
                if ('xr' in navigator) {
                    this.isVRSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    
                    const vrButton = document.getElementById('vr-button');
                    if (this.isVRSupported) {
                        vrButton.disabled = false;
                        vrButton.textContent = 'üöÄ Enter VR';
                    } else {
                        vrButton.disabled = true;
                        vrButton.textContent = '‚ùå VR Not Supported';
                    }
                } else {
                    document.getElementById('vr-button').disabled = true;
                    document.getElementById('vr-button').textContent = '‚ùå WebXR Not Available';
                }
                
                document.getElementById('vr-status').textContent = this.isVRSupported ? 'Supported' : 'Not Available';
            }
            
            async startVR() {
                try {
                    this.vrSession = await navigator.xr.requestSession('immersive-vr', {
                        requiredFeatures: ['local-floor'],
                        optionalFeatures: ['hand-tracking', 'layers']
                    });
                    
                    this.vrSession.addEventListener('end', () => {
                        this.endVR();
                    });
                    
                    this.vrSession.addEventListener('selectstart', (event) => {
                        this.onVRControllerSelect(event, true);
                    });
                    
                    this.vrSession.addEventListener('selectend', (event) => {
                        this.onVRControllerSelect(event, false);
                    });
                    
                    this.renderer.xr.setReferenceSpaceType('local-floor');
                    this.renderer.xr.setSession(this.vrSession);
                    
                    this.isVRActive = true;
                    this.sessionStartTime = Date.now();
                    
                    document.getElementById('vr-button').textContent = '‚èπÔ∏è Exit VR';
                    document.getElementById('vr-mode').textContent = 'VR';
                    document.getElementById('vr-instruction').style.display = 'block';
                    
                    this.setupVRControllers();
                    
                } catch (error) {
                    console.error('Failed to start VR session:', error);
                }
            }
            
            endVR() {
                if (this.vrSession) {
                    this.vrSession.end();
                }
                
                this.isVRActive = false;
                this.vrSession = null;
                
                document.getElementById('vr-button').textContent = 'üöÄ Enter VR';
                document.getElementById('vr-mode').textContent = 'Desktop';
                document.getElementById('vr-instruction').style.display = 'none';
            }
            
            setupVRControllers() {
                this.controllers = [];
                
                for (let i = 0; i < 2; i++) {
                    const controller = this.renderer.xr.getController(i);
                    this.scene.add(controller);
                    
                    // Controller visualization
                    const geometry = new Engine.CylinderGeometry(0.02, 0.02, 0.1);
                    const material = new Engine.MeshBasicMaterial({ color: 0x00ffff });
                    const controllerMesh = new Engine.Mesh(geometry, material);
                    controller.add(controllerMesh);
                    
                    controller.userData = {
                        grabbedObject: null,
                        velocity: new Engine.Vector3()
                    };
                    
                    this.controllers.push(controller);
                }
            }
            
            onVRControllerSelect(event, isStart) {
                const controller = event.target;
                
                if (isStart) {
                    // Try to grab object
                    const object = this.findNearestObject(controller.position, 0.3);
                    if (object) {
                        controller.userData.grabbedObject = object;
                        object.userData.grabbed = true;
                        this.grabbedObject = object;
                    }
                } else {
                    // Release object
                    if (controller.userData.grabbedObject) {
                        controller.userData.grabbedObject.userData.grabbed = false;
                        
                        // Calculate throw velocity
                        const velocity = controller.userData.velocity;
                        controller.userData.grabbedObject.userData.velocity.copy(velocity);
                        
                        controller.userData.grabbedObject = null;
                        this.grabbedObject = null;
                    }
                }
            }
            
            findNearestObject(position, maxDistance) {
                let nearest = null;
                let nearestDistance = maxDistance;
                
                this.interactiveObjects.forEach(object => {
                    const distance = object.position.distanceTo(position);
                    if (distance < nearestDistance) {
                        nearest = object;
                        nearestDistance = distance;
                    }
                });
                
                return nearest;
            }
            
            updateDesktopControls() {
                const velocity = new Engine.Vector3();
                
                // Movement
                if (this.keys['KeyW']) velocity.z -= this.movementSpeed * 0.016;
                if (this.keys['KeyS']) velocity.z += this.movementSpeed * 0.016;
                if (this.keys['KeyA']) velocity.x -= this.movementSpeed * 0.016;
                if (this.keys['KeyD']) velocity.x += this.movementSpeed * 0.016;
                
                if (this.keys['Space']) velocity.y += this.movementSpeed * 0.016;
                if (this.keys['ShiftLeft']) velocity.y -= this.movementSpeed * 0.016;
                
                // Apply camera rotation to movement
                velocity.applyEuler(this.camera.rotation);
                this.camera.position.add(velocity);
            }
            
            updateVRControllers() {
                this.controllers.forEach(controller => {
                    // Update controller velocity
                    if (controller.userData.previousPosition) {
                        const currentPos = controller.position;
                        const delta = currentPos.clone().sub(controller.userData.previousPosition);
                        controller.userData.velocity.copy(delta.multiplyScalar(60)); // Frame rate independent
                    }
                    controller.userData.previousPosition = controller.position.clone();
                    
                    // Update grabbed object
                    if (controller.userData.grabbedObject) {
                        controller.userData.grabbedObject.position.copy(controller.position);
                        controller.userData.grabbedObject.userData.velocity.set(0, 0, 0);
                    }
                });
            }
            
            updatePhysics() {
                this.interactiveObjects.forEach(object => {
                    if (!object.userData.grabbed) {
                        // Apply gravity
                        object.userData.velocity.y -= 9.81 * 0.016;
                        
                        // Apply velocity
                        object.position.add(object.userData.velocity.clone().multiplyScalar(0.016));
                        
                        // Simple ground collision
                        if (object.position.y < 0.1) {
                            object.position.y = 0.1;
                            object.userData.velocity.y *= -0.5; // Bounce
                            object.userData.velocity.x *= 0.8; // Friction
                        }
                        
                        // Boundary collision
                        const bounds = 9;
                        if (Math.abs(object.position.x) > bounds) {
                            object.position.x = Math.sign(object.position.x) * bounds;
                            object.userData.velocity.x *= -0.5;
                        }
                        if (Math.abs(object.position.z) > bounds) {
                            object.position.z = Math.sign(object.position.z) * bounds;
                            object.userData.velocity.z *= -0.5;
                        }
                    }
                    
                    // Rotation for floating cubes
                    if (object.userData.rotationSpeed) {
                        object.rotation.x += object.userData.rotationSpeed.x;
                        object.rotation.y += object.userData.rotationSpeed.y;
                        object.rotation.z += object.userData.rotationSpeed.z;
                    }
                });
            }
            
            updateUI() {
                const controllerCount = this.controllers.filter(c => c.userData.grabbedObject).length;
                document.getElementById('controller-count').textContent = controllerCount;
                
                if (this.isVRActive) {
                    const sessionTime = (Date.now() - this.sessionStartTime) / 1000;
                    document.getElementById('session-time').textContent = sessionTime.toFixed(1);
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.isVRActive) {
                    this.updateDesktopControls();
                } else {
                    this.updateVRControllers();
                }
                
                this.updatePhysics();
                this.updateUI();
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize VR experience
        window.addEventListener('load', () => {
            new VRExperience();
        });
        
        // Resize handling
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
