<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Game Engine Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: absolute; top: 20px; left: 20px; color: #fff; z-index: 1000;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px;
            font-size: 14px; line-height: 1.6;
        }
        #controls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; z-index: 1000; text-align: center;
        }
        #controls div { margin: 5px 0; }
        .key { background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 3px; }
        #game-stats {
            position: absolute; top: 20px; right: 20px; color: #0f0;
            font-size: 12px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="hud">
        <h3>SPACE DEFENDER</h3>
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
    </div>
    <div id="game-stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>Objects: <span id="objects">0</span></div>
        <div>Particles: <span id="particles">0</span></div>
    </div>
    <div id="controls">
        <div><span class="key">WASD</span> Move | <span class="key">SPACE</span> Fire | <span class="key">SHIFT</span> Boost</div>
        <div><span class="key">P</span> Pause | <span class="key">M</span> Mute | <span class="key">R</span> Reset</div>
    </div>
    <script src="../../src/index.js"></script>
    <script>
        // Game Engine System
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = this.canvas.getContext('webgl');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                // Engine systems
                this.scene = new Engine.Scene();
                this.camera = new Engine.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.renderer = new Engine.WebGLRenderer({ canvas: this.canvas, gl: this.gl });
                this.physics = new Engine.PhysicsSystem();
                this.audio = new Engine.AudioSystem();
                
                // Game state
                this.isPaused = false;
                this.isMuted = false;
                this.score = 0;
                this.health = 100;
                this.level = 1;
                
                // Player
                this.player = this.createPlayer();
                this.player.mesh.position.set(0, 0, 5);
                this.scene.add(this.player.mesh);
                
                // Game objects
                this.enemies = [];
                this.bullets = [];
                this.particles = [];
                this.stars = [];
                
                this.setupLighting();
                this.setupControls();
                this.createStarField();
                this.startAudio();
                
                this.lastTime = performance.now();
                this.frameCount = 0;
                this.fps = 60;
                
                this.animate();
            }
            
            createPlayer() {
                const geometry = new Engine.ConeGeometry(0.5, 2, 8);
                const material = new Engine.MeshBasicMaterial({ color: 0x00ff00 });
                const mesh = new Engine.Mesh(geometry, material);
                
                // Create engine glow
                const glowGeometry = new Engine.ConeGeometry(0.3, 1, 8);
                const glowMaterial = new Engine.MeshBasicMaterial({ 
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.7
                });
                const glow = new Engine.Mesh(glowGeometry, glowMaterial);
                glow.position.y = -1.5;
                mesh.add(glow);
                
                return {
                    mesh,
                    velocity: { x: 0, y: 0, z: 0 },
                    speed: 15,
                    health: 100,
                    maxHealth: 100,
                    cooldown: 0
                };
            }
            
            createEnemy(type = 'basic') {
                const types = {
                    basic: { geometry: new Engine.BoxGeometry(1, 1, 1), color: 0xff0000, health: 10 },
                    fast: { geometry: new Engine.ConeGeometry(0.5, 1, 6), color: 0xffff00, health: 5 },
                    boss: { geometry: new Engine.SphereGeometry(2, 8, 6), color: 0xaa00aa, health: 100 }
                };
                
                const config = types[type] || types.basic;
                const material = new Engine.MeshBasicMaterial({ color: config.color });
                const mesh = new Engine.Mesh(config.geometry, material);
                
                mesh.position.x = (Math.random() - 0.5) * 40;
                mesh.position.y = (Math.random() - 0.5) * 20;
                mesh.position.z = -50;
                
                return {
                    mesh,
                    type,
                    health: config.health,
                    maxHealth: config.health,
                    velocity: { x: 0, y: 0, z: 5 + Math.random() * 3 },
                    shootCooldown: 0,
                    score: config.health * 10
                };
            }
            
            createBullet(x, y, z, direction, owner) {
                const geometry = new Engine.SphereGeometry(0.1, 4, 2);
                const color = owner === 'player' ? 0x00ffff : 0xff4400;
                const material = new Engine.MeshBasicMaterial({ color, transparent: true, opacity: 0.9 });
                const mesh = new Engine.Mesh(geometry, material);
                
                mesh.position.set(x, y, z);
                
                return {
                    mesh,
                    owner,
                    velocity: { x: direction.x * 20, y: direction.y * 20, z: direction.z * 20 },
                    damage: 10,
                    lifetime: 0
                };
            }
            
            createExplosion(x, y, z, color = 0xffaa00, count = 20) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 10 + 5;
                    const geometry = new Engine.SphereGeometry(0.05, 2, 1);
                    const material = new Engine.MeshBasicMaterial({ 
                        color, 
                        transparent: true, 
                        opacity: 0.8 
                    });
                    const mesh = new Engine.Mesh(geometry, material);
                    
                    mesh.position.set(x, y, z);
                    
                    this.particles.push({
                        mesh,
                        velocity: {
                            x: Math.cos(angle) * speed,
                            y: Math.sin(angle) * speed,
                            z: (Math.random() - 0.5) * 5
                        },
                        lifetime: 1,
                        maxLifetime: 1,
                        decay: 0.02
                    });
                    
                    this.scene.add(mesh);
                }
            }
            
            createStarField() {
                for (let i = 0; i < 1000; i++) {
                    const geometry = new Engine.SphereGeometry(0.02, 2, 1);
                    const material = new Engine.MeshBasicMaterial({ color: 0xffffff });
                    const star = new Engine.Mesh(geometry, material);
                    
                    star.position.x = (Math.random() - 0.5) * 200;
                    star.position.y = (Math.random() - 0.5) * 200;
                    star.position.z = -Math.random() * 1000;
                    
                    this.stars.push({
                        mesh: star,
                        speed: Math.random() * 2 + 1
                    });
                    
                    this.scene.add(star);
                }
            }
            
            setupLighting() {
                const ambientLight = new Engine.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new Engine.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                const pointLight = new Engine.PointLight(0x00ff00, 1, 50);
                pointLight.position.set(0, 0, 3);
                this.player.mesh.add(pointLight);
            }
            
            setupControls() {
                this.keys = {};
                
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Space') e.preventDefault();
                    if (e.code === 'KeyP') this.togglePause();
                    if (e.code === 'KeyM') this.toggleMute();
                    if (e.code === 'KeyR') this.resetGame();
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse for aiming
                this.canvas.addEventListener('mousemove', (e) => {
                    if (e.buttons === 1) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = (e.clientX - rect.left) / rect.width * 2 - 1;
                        const y = -(e.clientY - rect.top) / rect.height * 2 + 1;
                        
                        this.player.mesh.rotation.z = x * 0.5;
                        this.player.mesh.rotation.x = y * 0.3;
                    }
                });
            }
            
            startAudio() {
                // Simple beep sounds (would need Web Audio API for real audio)
                this.playSound = (frequency, duration) => {
                    if (this.isMuted) return;
                    
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                };
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
            }
            
            resetGame() {
                this.score = 0;
                this.health = 100;
                this.level = 1;
                this.player.mesh.position.set(0, 0, 5);
                this.enemies.forEach(enemy => this.scene.remove(enemy.mesh));
                this.enemies = [];
                this.bullets.forEach(bullet => this.scene.remove(bullet.mesh));
                this.bullets = [];
            }
            
            handleInput() {
                const player = this.player;
                const speed = this.keys['ShiftLeft'] ? player.speed * 2 : player.speed;
                
                // Movement
                if (this.keys['KeyW']) player.velocity.y = speed;
                else if (this.keys['KeyS']) player.velocity.y = -speed;
                else player.velocity.y *= 0.9;
                
                if (this.keys['KeyA']) player.velocity.x = -speed;
                else if (this.keys['KeyD']) player.velocity.x = speed;
                else player.velocity.x *= 0.9;
                
                // Apply velocity
                player.mesh.position.x += player.velocity.x * 0.016;
                player.mesh.position.y += player.velocity.y * 0.016;
                
                // Keep player in bounds
                player.mesh.position.x = Math.max(-20, Math.min(20, player.mesh.position.x));
                player.mesh.position.y = Math.max(-10, Math.min(10, player.mesh.position.y));
                
                // Shooting
                if (this.keys['Space'] && player.cooldown <= 0) {
                    const direction = { x: 0, y: 0, z: -1 };
                    const bullet = this.createBullet(
                        player.mesh.position.x,
                        player.mesh.position.y,
                        player.mesh.position.z - 1,
                        direction,
                        'player'
                    );
                    
                    this.bullets.push(bullet);
                    this.scene.add(bullet.mesh);
                    player.cooldown = 0.2;
                    
                    if (!this.isMuted) this.playSound(800, 0.1);
                }
                
                player.cooldown -= 0.016;
            }
            
            updateGameObjects() {
                // Update enemies
                this.enemies.forEach((enemy, index) => {
                    enemy.mesh.position.x += enemy.velocity.x * 0.016;
                    enemy.mesh.position.y += enemy.velocity.y * 0.016;
                    enemy.mesh.position.z += enemy.velocity.z * 0.016;
                    
                    // Remove if too far
                    if (enemy.mesh.position.z > 20) {
                        this.scene.remove(enemy.mesh);
                        this.enemies.splice(index, 1);
                        this.health -= enemy.health;
                    }
                    
                    // Enemy shooting
                    if (enemy.shootCooldown <= 0 && Math.random() < 0.01) {
                        const direction = {
                            x: this.player.mesh.position.x - enemy.mesh.position.x,
                            y: this.player.mesh.position.y - enemy.mesh.position.y,
                            z: this.player.mesh.position.z - enemy.mesh.position.z
                        };
                        
                        const length = Math.sqrt(direction.x ** 2 + direction.y ** 2 + direction.z ** 2);
                        direction.x /= length;
                        direction.y /= length;
                        direction.z /= length;
                        
                        const bullet = this.createBullet(
                            enemy.mesh.position.x,
                            enemy.mesh.position.y,
                            enemy.mesh.position.z + 1,
                            direction,
                            'enemy'
                        );
                        
                        this.bullets.push(bullet);
                        this.scene.add(bullet.mesh);
                        enemy.shootCooldown = 2;
                    }
                    
                    enemy.shootCooldown -= 0.016;
                });
                
                // Update bullets
                this.bullets.forEach((bullet, index) => {
                    bullet.mesh.position.x += bullet.velocity.x * 0.016;
                    bullet.mesh.position.y += bullet.velocity.y * 0.016;
                    bullet.mesh.position.z += bullet.velocity.z * 0.016;
                    
                    bullet.lifetime += 0.016;
                    
                    // Remove if too old or out of bounds
                    if (bullet.lifetime > 5 || 
                        Math.abs(bullet.mesh.position.x) > 50 ||
                        Math.abs(bullet.mesh.position.y) > 50 ||
                        Math.abs(bullet.mesh.position.z) > 100) {
                        this.scene.remove(bullet.mesh);
                        this.bullets.splice(index, 1);
                    }
                });
                
                // Update particles
                this.particles.forEach((particle, index) => {
                    particle.mesh.position.x += particle.velocity.x * 0.016;
                    particle.mesh.position.y += particle.velocity.y * 0.016;
                    particle.mesh.position.z += particle.velocity.z * 0.016;
                    
                    particle.lifetime -= particle.decay;
                    particle.mesh.material.opacity = particle.lifetime / particle.maxLifetime;
                    
                    if (particle.lifetime <= 0) {
                        this.scene.remove(particle.mesh);
                        this.particles.splice(index, 1);
                    }
                });
                
                // Update stars
                this.stars.forEach(star => {
                    star.mesh.position.z += star.speed * 0.016;
                    
                    if (star.mesh.position.z > 10) {
                        star.mesh.position.z = -1000;
                        star.mesh.position.x = (Math.random() - 0.5) * 200;
                        star.mesh.position.y = (Math.random() - 0.5) * 200;
                    }
                });
            }
            
            checkCollisions() {
                // Bullet vs Enemy
                this.bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.owner !== 'player') return;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        const dx = bullet.mesh.position.x - enemy.mesh.position.x;
                        const dy = bullet.mesh.position.y - enemy.mesh.position.y;
                        const dz = bullet.mesh.position.z - enemy.mesh.position.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance < 1.5) {
                            enemy.health -= bullet.damage;
                            
                            // Create hit particles
                            this.createExplosion(
                                enemy.mesh.position.x,
                                enemy.mesh.position.y,
                                enemy.mesh.position.z,
                                0xff4400,
                                5
                            );
                            
                            this.scene.remove(bullet.mesh);
                            this.bullets.splice(bulletIndex, 1);
                            
                            if (enemy.health <= 0) {
                                this.score += enemy.score;
                                this.createExplosion(
                                    enemy.mesh.position.x,
                                    enemy.mesh.position.y,
                                    enemy.mesh.position.z,
                                    0xffaa00,
                                    15
                                );
                                
                                this.scene.remove(enemy.mesh);
                                this.enemies.splice(enemyIndex, 1);
                                
                                if (!this.isMuted) this.playSound(400, 0.3);
                            }
                        }
                    });
                });
                
                // Enemy bullet vs Player
                this.bullets.forEach((bullet, bulletIndex) => {
                    if (bullet.owner !== 'enemy') return;
                    
                    const dx = bullet.mesh.position.x - this.player.mesh.position.x;
                    const dy = bullet.mesh.position.y - this.player.mesh.position.y;
                    const dz = bullet.mesh.position.z - this.player.mesh.position.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < 2) {
                        this.health -= bullet.damage;
                        
                        this.createExplosion(
                            this.player.mesh.position.x,
                            this.player.mesh.position.y,
                            this.player.mesh.position.z,
                            0xff0000,
                            3
                        );
                        
                        this.scene.remove(bullet.mesh);
                        this.bullets.splice(bulletIndex, 1);
                        
                        if (!this.isMuted) this.playSound(200, 0.2);
                    }
                });
            }
            
            spawnEnemies() {
                if (Math.random() < 0.02 + this.level * 0.005) {
                    const types = ['basic', 'fast'];
                    const weights = [0.7, 0.3];
                    
                    let random = Math.random();
                    let selectedType = 'basic';
                    
                    for (let i = 0; i < types.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            selectedType = types[i];
                            break;
                        }
                    }
                    
                    const enemy = this.createEnemy(selectedType);
                    this.enemies.push(enemy);
                    this.scene.add(enemy.mesh);
                }
            }
            
            updateLevel() {
                if (this.score > this.level * 1000) {
                    this.level++;
                    this.createExplosion(
                        0, 0, 0, 
                        0x00ff00, 
                        30
                    );
                    
                    if (!this.isMuted) this.playSound(1000, 0.5);
                }
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('health').textContent = Math.max(0, this.health);
                document.getElementById('level').textContent = this.level;
                document.getElementById('enemies').textContent = this.enemies.length;
                
                // Game over
                if (this.health <= 0) {
                    this.isPaused = true;
                    this.createExplosion(
                        this.player.mesh.position.x,
                        this.player.mesh.position.y,
                        this.player.mesh.position.z,
                        0xff0000,
                        50
                    );
                    
                    setTimeout(() => this.resetGame(), 3000);
                }
            }
            
            updateStats() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('objects').textContent = 
                        1 + this.enemies.length + this.bullets.length + this.particles.length;
                    document.getElementById('particles').textContent = this.particles.length;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.isPaused) {
                    this.handleInput();
                    this.updateGameObjects();
                    this.checkCollisions();
                    this.spawnEnemies();
                    this.updateLevel();
                    this.updateUI();
                }
                
                this.updateStats();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the game
        window.addEventListener('load', () => {
            new GameEngine();
        });
        
        // Resize handling
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>
