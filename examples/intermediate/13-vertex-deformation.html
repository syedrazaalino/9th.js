<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertex Deformation Demo</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            max-width: 250px;
        }
        .control-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; font-size: 12px; }
        input[type="range"] { width: 100%; }
        button {
            margin: 2px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #666; }
        button.active { background: #007acc; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Vertex Deformation Demo</strong><br>
        Morph targets and shape blending<br>
        - Real-time vertex manipulation<br>
        - Morph target animation<br>
        - Blending between shapes<br>
        - Dynamic surface deformation
    </div>
    
    <div id="controls">
        <div class="control-group">
            <button onclick="setDeformationMode('wave')" class="active">Wave</button>
            <button onclick="setDeformationMode('explosion')">Explosion</button>
            <button onclick="setDeformationMode('twist')">Twist</button>
            <button onclick="setDeformationMode('breathing')">Breathing</button>
        </div>
        <div class="control-group">
            <label>Deformation Strength: <span id="strength-val">1.0</span></label>
            <input type="range" id="deformation-strength" min="0" max="2" step="0.01" value="1.0">
        </div>
        <div class="control-group">
            <label>Frequency: <span id="frequency-val">2.0</span></label>
            <input type="range" id="deformation-frequency" min="0.5" max="10" step="0.1" value="2.0">
        </div>
        <div class="control-group">
            <button onclick="resetGeometry()">Reset</button>
            <button onclick="toggleWireframe()">Wireframe</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "three/addons/": "../node_modules/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 8);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Vertex Deformation System
        class VertexDeformationSystem {
            constructor() {
                this.geometry = null;
                this.mesh = null;
                this.originalPositions = null;
                this.currentPositions = null;
                this.normals = null;
                this.deformationMode = 'wave';
                this.deformationStrength = 1.0;
                this.deformationFrequency = 2.0;
                this.wireframe = false;

                this.createDeformableMesh();
            }

            createDeformableMesh() {
                // Create high-resolution sphere for deformation
                this.geometry = new THREE.SphereGeometry(2, 64, 32);
                this.geometry.computeVertexNormals();

                const material = new THREE.MeshLambertMaterial({
                    color: 0x4a90e2,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(this.geometry, material);
                scene.add(this.mesh);

                // Store original positions
                this.originalPositions = new Float32Array(this.geometry.attributes.position.array);
                this.currentPositions = new Float32Array(this.geometry.attributes.position.array);
                this.normals = new Float32Array(this.geometry.attributes.normal.array);
            }

            setDeformationMode(mode) {
                this.deformationMode = mode;
            }

            setDeformationStrength(strength) {
                this.deformationStrength = strength;
            }

            setDeformationFrequency(frequency) {
                this.deformationFrequency = frequency;
            }

            reset() {
                // Reset to original positions
                for (let i = 0; i < this.currentPositions.length; i++) {
                    this.currentPositions[i] = this.originalPositions[i];
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.computeVertexNormals();
            }

            toggleWireframe() {
                this.wireframe = !this.wireframe;
                this.mesh.material.wireframe = this.wireframe;
            }

            deform(time) {
                const positions = this.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = this.originalPositions[i];
                    const y = this.originalPositions[i + 1];
                    const z = this.originalPositions[i + 2];
                    
                    let deformation = 0;
                    
                    switch(this.deformationMode) {
                        case 'wave':
                            deformation = Math.sin(time * this.deformationFrequency + x * 2 + y * 2) * 0.3;
                            const normalX = this.normals[i];
                            const normalY = this.normals[i + 1];
                            const normalZ = this.normals[i + 2];
                            positions[i] = x + normalX * deformation * this.deformationStrength;
                            positions[i + 1] = y + normalY * deformation * this.deformationStrength;
                            positions[i + 2] = z + normalZ * deformation * this.deformationStrength;
                            break;

                        case 'explosion':
                            const distance = Math.sqrt(x * x + y * y + z * z);
                            const direction = { x: x / distance, y: y / distance, z: z / distance };
                            const explosionWave = Math.sin(time * 5 - distance * 2) * Math.exp(-distance * 0.5);
                            positions[i] = x + direction.x * explosionWave * this.deformationStrength;
                            positions[i + 1] = y + direction.y * explosionWave * this.deformationStrength;
                            positions[i + 2] = z + direction.z * explosionWave * this.deformationStrength;
                            break;

                        case 'twist':
                            const twistAngle = y * this.deformationFrequency * time;
                            const cos = Math.cos(twistAngle);
                            const sin = Math.sin(twistAngle);
                            positions[i] = x * cos - z * sin;
                            positions[i + 2] = x * sin + z * cos;
                            positions[i + 1] = y + Math.sin(time + x * 2) * 0.2 * this.deformationStrength;
                            break;

                        case 'breathing':
                            const breathing = Math.sin(time) * 0.1 + 1.0;
                            const radialDistance = Math.sqrt(x * x + y * y + z * z);
                            const directionX = x / radialDistance;
                            const directionY = y / radialDistance;
                            const directionZ = z / radialDistance;
                            positions[i] = x * breathing + directionX * Math.sin(time * 3 + radialDistance * 2) * 0.3 * this.deformationStrength;
                            positions[i + 1] = y * breathing + directionY * Math.sin(time * 3 + radialDistance * 2) * 0.3 * this.deformationStrength;
                            positions[i + 2] = z * breathing + directionZ * Math.sin(time * 3 + radialDistance * 2) * 0.3 * this.deformationStrength;
                            break;
                    }
                }

                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.computeVertexNormals();
            }
        }

        // Create deformation system
        const deformationSystem = new VertexDeformationSystem();

        // Add a second mesh to show morphing between shapes
        const morphGeometry = new THREE.BoxGeometry(3, 3, 3, 32, 32, 32);
        morphGeometry.computeVertexNormals();
        const morphMaterial = new THREE.MeshLambertMaterial({
            color: 0xe74c3c,
            transparent: true,
            opacity: 0.7
        });
        const morphMesh = new THREE.Mesh(morphGeometry, morphMaterial);
        morphMesh.position.set(-5, 0, 0);
        scene.add(morphMesh);

        // Store original morph positions
        const originalMorphPositions = new Float32Array(morphGeometry.attributes.position.array);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Point lights for dramatic effect
        const pointLight1 = new THREE.PointLight(0xffffff, 0.8, 20);
        pointLight1.position.set(-10, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x4a90e2, 0.6, 15);
        pointLight2.position.set(10, -5, -5);
        scene.add(pointLight2);

        // Global functions
        window.setDeformationMode = (mode) => {
            deformationSystem.setDeformationMode(mode);
            
            // Update button states
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        };

        window.resetGeometry = () => {
            deformationSystem.reset();
            
            // Reset morph mesh
            const positions = morphGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i++) {
                positions[i] = originalMorphPositions[i];
            }
            morphGeometry.attributes.position.needsUpdate = true;
            morphGeometry.computeVertexNormals();
        };

        window.toggleWireframe = () => {
            deformationSystem.toggleWireframe();
            morphMesh.material.wireframe = !morphMesh.material.wireframe;
        };

        // Control bindings
        const strengthSlider = document.getElementById('deformation-strength');
        const strengthDisplay = document.getElementById('strength-val');
        strengthSlider.addEventListener('input', (e) => {
            const strength = parseFloat(e.target.value);
            deformationSystem.setDeformationStrength(strength);
            strengthDisplay.textContent = strength.toFixed(2);
        });

        const frequencySlider = document.getElementById('deformation-frequency');
        const frequencyDisplay = document.getElementById('frequency-val');
        frequencySlider.addEventListener('input', (e) => {
            const frequency = parseFloat(e.target.value);
            deformationSystem.setDeformationFrequency(frequency);
            frequencyDisplay.textContent = frequency.toFixed(1);
        });

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Deform main mesh
            deformationSystem.deform(elapsedTime);

            // Morph second mesh between shapes
            const morphPositions = morphGeometry.attributes.position.array;
            const morphAmount = (Math.sin(elapsedTime * 2) + 1) / 2;
            
            for (let i = 0; i < morphPositions.length; i += 3) {
                const originalX = originalMorphPositions[i];
                const originalY = originalMorphPositions[i + 1];
                const originalZ = originalMorphPositions[i + 2];
                
                // Create a twisted sphere-like shape
                const distance = Math.sqrt(originalX * originalX + originalY * originalY + originalZ * originalZ);
                const twistAmount = originalY * elapsedTime;
                
                morphPositions[i] = originalX * Math.cos(twistAmount) - originalZ * Math.sin(twistAmount);
                morphPositions[i + 1] = originalY * (1 + morphAmount * 0.5);
                morphPositions[i + 2] = originalX * Math.sin(twistAmount) + originalZ * Math.cos(twistAmount);
            }
            
            morphGeometry.attributes.position.needsUpdate = true;
            morphGeometry.computeVertexNormals();

            // Rotate meshes
            deformationSystem.mesh.rotation.y = elapsedTime * 0.3;
            morphMesh.rotation.x = elapsedTime * 0.2;
            morphMesh.rotation.y = elapsedTime * 0.4;

            // Move lights
            pointLight1.position.x = Math.sin(elapsedTime * 0.5) * 15;
            pointLight1.position.z = Math.cos(elapsedTime * 0.5) * 15;
            pointLight2.position.x = Math.sin(elapsedTime * 0.8 + Math.PI / 2) * 12;
            pointLight2.position.z = Math.cos(elapsedTime * 0.8 + Math.PI / 2) * 12;

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
