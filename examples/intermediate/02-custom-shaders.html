<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Shaders GLSL Demo</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
        }
        .control-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; }
        input[type="range"] { width: 100%; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Custom Shaders GLSL Demo</strong><br>
        Custom vertex and fragment shaders<br>
        - Procedural patterns<br>
        - Wave deformation<br>
        - Color gradients<br>
        - Interactive uniforms
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label>Wave Amplitude: <span id="amplitude-val">0.5</span></label>
            <input type="range" id="amplitude" min="0" max="2" step="0.01" value="0.5">
        </div>
        <div class="control-group">
            <label>Wave Frequency: <span id="frequency-val">1.0</span></label>
            <input type="range" id="frequency" min="0.1" max="3" step="0.01" value="1.0">
        </div>
        <div class="control-group">
            <label>Pattern Scale: <span id="pattern-val">2.0</span></label>
            <input type="range" id="pattern" min="0.5" max="5" step="0.1" value="2.0">
        </div>
        <div class="control-group">
            <label>Rotation Speed: <span id="rotation-val">1.0</span></label>
            <input type="range" id="rotation" min="0" max="3" step="0.01" value="1.0">
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "three/addons/": "../node_modules/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Custom vertex shader
        const vertexShader = `
            uniform float time;
            uniform float amplitude;
            uniform float frequency;
            uniform float patternScale;
            varying vec3 vPosition;
            varying vec2 vUv;
            varying vec3 vNormal;

            void main() {
                vPosition = position;
                vUv = uv;
                vNormal = normal;
                
                // Wave deformation based on position and time
                float waveX = sin(position.x * frequency + time) * amplitude;
                float waveY = sin(position.y * frequency + time * 1.2) * amplitude;
                float waveZ = sin(position.z * frequency + time * 0.8) * amplitude;
                
                vec3 deformedPosition = position + normal * (waveX + waveY + waveZ);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(deformedPosition, 1.0);
            }
        `;

        // Custom fragment shader
        const fragmentShader = `
            uniform float time;
            uniform float patternScale;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            varying vec3 vPosition;
            varying vec2 vUv;
            varying vec3 vNormal;

            void main() {
                // Create procedural patterns
                vec2 scaledUv = vUv * patternScale;
                
                // Checkerboard pattern
                float checker = mod(floor(scaledUv.x) + floor(scaledUv.y), 2.0);
                
                // Stripes pattern
                float stripes = sin(scaledUv.x * 20.0 + time * 2.0) * 0.5 + 0.5;
                
                // Circular pattern
                vec2 centerUv = scaledUv - 0.5;
                float circle = 1.0 - smoothstep(0.0, 0.5, length(centerUv));
                
                // Wave pattern
                float wave = sin(scaledUv.x * 10.0 + scaledUv.y * 10.0 + time) * 0.5 + 0.5;
                
                // Combine patterns
                vec3 pattern = mix(color1, color2, checker);
                pattern = mix(pattern, color3, stripes * 0.3);
                pattern = mix(pattern, vec3(1.0, 1.0, 0.0), circle * 0.2);
                pattern = mix(pattern, vec3(1.0, 0.0, 1.0), wave * 0.1);
                
                // Add lighting effect
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                float lighting = dot(normalize(vNormal), lightDir) * 0.5 + 0.5;
                
                // Final color
                gl_FragColor = vec4(pattern * lighting, 1.0);
            }
        `;

        // Uniforms for the shader
        const uniforms = {
            time: { value: 0 },
            amplitude: { value: 0.5 },
            frequency: { value: 1.0 },
            patternScale: { value: 2.0 },
            color1: { value: new THREE.Color(0xff6b35) },
            color2: { value: new THREE.Color(0x4a90e2) },
            color3: { value: new THREE.Color(0x2ecc71) }
        };

        // Create shader material
        const shaderMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            side: THREE.DoubleSide,
            wireframe: false
        });

        // Create multiple objects with different shapes
        const objects = [];

        // Torus knot
        const torusKnotGeometry = new THREE.TorusKnotGeometry(1.5, 0.4, 100, 16);
        const torusKnot = new THREE.Mesh(torusKnotGeometry, shaderMaterial);
        torusKnot.position.set(-4, 0, 0);
        scene.add(torusKnot);
        objects.push(torusKnot);

        // Sphere with higher segments
        const sphereGeometry = new THREE.SphereGeometry(1.8, 64, 32);
        const sphere = new THREE.Mesh(sphereGeometry, shaderMaterial);
        sphere.position.set(4, 0, 0);
        scene.add(sphere);
        objects.push(sphere);

        // Plane with high segment count for deformation
        const planeGeometry = new THREE.PlaneGeometry(6, 6, 100, 100);
        const plane = new THREE.Mesh(planeGeometry, shaderMaterial);
        plane.position.set(0, 0, -4);
        scene.add(plane);
        objects.push(plane);

        // Box geometry
        const boxGeometry = new THREE.BoxGeometry(3, 3, 3, 20, 20, 20);
        const box = new THREE.Mesh(boxGeometry, shaderMaterial);
        box.position.set(0, 0, 4);
        scene.add(box);
        objects.push(box);

        // Wireframe version for comparison
        const wireframeMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            side: THREE.DoubleSide,
            wireframe: true
        });

        const torusWireframe = new THREE.Mesh(torusKnotGeometry.clone(), wireframeMaterial);
        torusWireframe.position.copy(torusKnot.position).add(new THREE.Vector3(0, 0, 0));
        scene.add(torusWireframe);

        // Control bindings
        function bindControl(id, uniformKey, displayId) {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                uniforms[uniformKey].value = value;
                display.textContent = value.toFixed(2);
            });
        }

        bindControl('amplitude', 'amplitude', 'amplitude-val');
        bindControl('frequency', 'frequency', 'frequency-val');
        bindControl('pattern', 'patternScale', 'pattern-val');
        bindControl('rotation', 'amplitude', 'rotation-val'); // Reusing amplitude for rotation speed

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update shader time
            uniforms.time.value = elapsedTime;

            // Rotate objects with different speeds
            objects.forEach((obj, index) => {
                obj.rotation.x = elapsedTime * (0.5 + index * 0.2);
                obj.rotation.y = elapsedTime * (0.3 + index * 0.1);
                obj.rotation.z = elapsedTime * (0.4 + index * 0.15);
            });

            torusWireframe.rotation.x = elapsedTime * 0.5;
            torusWireframe.rotation.y = elapsedTime * 0.3;

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
