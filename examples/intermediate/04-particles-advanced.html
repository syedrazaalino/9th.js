<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced GPU Particles Demo</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
        }
        .control-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; }
        input[type="range"] { width: 100%; }
        button {
            margin: 2px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #666; }
        button.active { background: #007acc; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Advanced GPU Particles Demo</strong><br>
        GPU-accelerated particle systems<br>
        - Massive particle counts<br>
        - Compute shader simulation<br>
        - Multiple particle systems<br>
        - Interactive particle types
    </div>
    
    <div id="controls">
        <div class="control-group">
            <button onclick="setParticleSystem('fire')" class="active">Fire</button>
            <button onclick="setParticleSystem('explosion')">Explosion</button>
            <button onclick="setParticleSystem('galaxy')">Galaxy</button>
            <button onclick="setParticleSystem('rain')">Rain</button>
        </div>
        <div class="control-group">
            <label>Particle Count: <span id="count-val">10000</span></label>
            <input type="range" id="particle-count" min="1000" max="50000" step="1000" value="10000">
        </div>
        <div class="control-group">
            <label>Particle Size: <span id="size-val">1.0</span></label>
            <input type="range" id="particle-size" min="0.1" max="5" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Simulation Speed: <span id="speed-val">1.0</span></label>
            <input type="range" id="sim-speed" min="0.1" max="3" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <button onclick="resetParticles()">Reset</button>
            <button onclick="togglePause()">Pause</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "three/addons/": "../node_modules/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 20, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);
        camera.lookAt(0, 0, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Advanced Particle System
        class GPUParticleSystem {
            constructor(maxParticles = 50000) {
                this.maxParticles = maxParticles;
                this.particleCount = 10000;
                this.particleSystem = null;
                this.particleTexture = null;
                this.clock = new THREE.Clock();
                this.time = 0;
                this.isPaused = false;

                this.createTextures();
                this.createParticles();
                this.setupSystems();
            }

            createTextures() {
                // Create circular sprite texture for particles
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');

                // Create radial gradient
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.4)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');

                context.fillStyle = gradient;
                context.fillRect(0, 0, 64, 64);

                this.particleTexture = new THREE.CanvasTexture(canvas);
                this.particleTexture.minFilter = THREE.LinearFilter;
                this.particleTexture.magFilter = THREE.LinearFilter;
                this.particleTexture.wrapS = THREE.ClampToEdgeWrapping;
                this.particleTexture.wrapT = THREE.ClampToEdgeWrapping;
            }

            createParticles() {
                const positions = new Float32Array(this.maxParticles * 3);
                const colors = new Float32Array(this.maxParticles * 3);
                const sizes = new Float32Array(this.maxParticles);
                const velocities = new Float32Array(this.maxParticles * 3);
                const lifetimes = new Float32Array(this.maxParticles);
                const ages = new Float32Array(this.maxParticles);
                const active = new Float32Array(this.maxParticles);

                // Initialize particles
                for (let i = 0; i < this.maxParticles; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    colors[i * 3] = Math.random();
                    colors[i * 3 + 1] = Math.random();
                    colors[i * 3 + 2] = Math.random();
                    
                    sizes[i] = Math.random() * 2 + 1;
                    
                    velocities[i * 3] = (Math.random() - 0.5) * 10;
                    velocities[i * 3 + 1] = Math.random() * 10;
                    velocities[i * 3 + 2] = (Math.random() - 0.5) * 10;
                    
                    lifetimes[i] = Math.random() * 5 + 2;
                    ages[i] = 0;
                    active[i] = 0;
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('age', new THREE.BufferAttribute(ages, 1));
                geometry.setAttribute('active', new THREE.BufferAttribute(active, 1));

                // Particle shader material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        particleTexture: { value: this.particleTexture },
                        pixelRatio: { value: renderer.getPixelRatio() },
                        systemCenter: { value: new THREE.Vector3(0, 0, 0) },
                        gravity: { value: new THREE.Vector3(0, -9.8, 0) },
                        systemType: { value: 0 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        attribute vec3 velocity;
                        attribute float lifetime;
                        attribute float age;
                        attribute float active;
                        
                        uniform float time;
                        uniform float pixelRatio;
                        uniform vec3 systemCenter;
                        uniform vec3 gravity;
                        uniform int systemType;
                        
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            vColor = customColor;
                            
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            
                            float lifeRatio = age / lifetime;
                            vAlpha = (1.0 - lifeRatio) * active;
                            
                            // Different size based on lifetime
                            float sizeAdjustment = size * (1.0 - lifeRatio * 0.5);
                            
                            gl_PointSize = sizeAdjustment * (300.0 / -mvPosition.z) * pixelRatio;
                            
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D particleTexture;
                        
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            gl_FragColor = vec4(vColor, vAlpha);
                            
                            vec4 texture = texture2D(particleTexture, gl_PointCoord);
                            gl_FragColor *= texture;
                            
                            if (gl_FragColor.a < 0.01) discard;
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthTest: false,
                    transparent: true,
                    vertexColors: true
                });

                this.particleSystem = new THREE.Points(geometry, material);
                scene.add(this.particleSystem);
            }

            setupSystems() {
                this.systems = {
                    fire: {
                        center: new THREE.Vector3(0, -5, 0),
                        gravity: new THREE.Vector3(0, 5, 0),
                        color1: new THREE.Color(0xff3300),
                        color2: new THREE.Color(0xffaa00),
                        color3: new THREE.Color(0xffff00),
                        spawnRate: 0.8,
                        lifetime: [2, 4],
                        velocity: [0, 3, 0]
                    },
                    explosion: {
                        center: new THREE.Vector3(0, 0, 0),
                        gravity: new THREE.Vector3(0, -5, 0),
                        color1: new THREE.Color(0xff0000),
                        color2: new THREE.Color(0xff8800),
                        color3: new THREE.Color(0xffff00),
                        spawnRate: 0.2,
                        lifetime: [3, 6],
                        velocity: [5, 10, 5]
                    },
                    galaxy: {
                        center: new THREE.Vector3(0, 0, 0),
                        gravity: new THREE.Vector3(0, 0, 0),
                        color1: new THREE.Color(0x4400ff),
                        color2: new Color(0x8844ff),
                        color3: new THREE.Color(0xff44ff),
                        spawnRate: 0.1,
                        lifetime: [10, 20],
                        velocity: [0, 0, 0]
                    },
                    rain: {
                        center: new THREE.Vector3(0, 15, 0),
                        gravity: new THREE.Vector3(0, -20, 0),
                        color1: new THREE.Color(0x4488ff),
                        color2: new THREE.Color(0x88ccff),
                        color3: new THREE.Color(0xffffff),
                        spawnRate: 0.9,
                        lifetime: [3, 5],
                        velocity: [0, -5, 0]
                    }
                };
            }

            setSystem(systemName) {
                const system = this.systems[systemName];
                if (!system) return;

                this.currentSystem = systemName;
                this.particleSystem.material.uniforms.systemCenter.value.copy(system.center);
                this.particleSystem.material.uniforms.gravity.value.copy(system.gravity);
            }

            update(deltaTime) {
                if (this.isPaused) return;

                this.time += deltaTime;
                this.particleSystem.material.uniforms.time.value = this.time;

                const geometry = this.particleSystem.geometry;
                const positions = geometry.attributes.position.array;
                const colors = geometry.attributes.customColor.array;
                const velocities = geometry.attributes.velocity.array;
                const lifetimes = geometry.attributes.lifetime.array;
                const ages = geometry.attributes.age.array;
                const active = geometry.attributes.active.array;

                const system = this.systems[this.currentSystem];

                // Update particles
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;

                    if (active[i] > 0.5) {
                        // Update active particle
                        ages[i] += deltaTime;
                        
                        // Apply gravity
                        velocities[i3] += system.gravity.x * deltaTime;
                        velocities[i3 + 1] += system.gravity.y * deltaTime;
                        velocities[i3 + 2] += system.gravity.z * deltaTime;

                        // Update position
                        positions[i3] += velocities[i3] * deltaTime;
                        positions[i3 + 1] += velocities[i3 + 1] * deltaTime;
                        positions[i3 + 2] += velocities[i3 + 2] * deltaTime;

                        // Kill particle if lifetime exceeded
                        if (ages[i] >= lifetimes[i]) {
                            this.respawnParticle(i);
                        }
                    } else {
                        // Respawn inactive particle
                        if (Math.random() < system.spawnRate) {
                            this.respawnParticle(i);
                        }
                    }
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.velocity.needsUpdate = true;
                geometry.attributes.age.needsUpdate = true;
                geometry.attributes.active.needsUpdate = true;
            }

            respawnParticle(i) {
                const i3 = i * 3;
                const system = this.systems[this.currentSystem];

                // Set position at system center
                positions[i3] = system.center.x + (Math.random() - 0.5) * 2;
                positions[i3 + 1] = system.center.y + (Math.random() - 0.5) * 2;
                positions[i3 + 2] = system.center.z + (Math.random() - 0.5) * 2;

                // Set random velocity based on system
                const velRange = system.velocity;
                velocities[i3] = (Math.random() - 0.5) * velRange[0] * 2;
                velocities[i3 + 1] = Math.random() * velRange[1];
                velocities[i3 + 2] = (Math.random() - 0.5) * velRange[2] * 2;

                // Set random lifetime
                lifetimes[i] = Math.random() * (system.lifetime[1] - system.lifetime[0]) + system.lifetime[0];
                ages[i] = 0;
                active[i] = 1;

                // Set color based on system
                const color = new THREE.Color().copy(system.color1).lerp(
                    system.color2, Math.random()
                ).lerp(system.color3, Math.random() * 0.5);

                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }

            setParticleCount(count) {
                this.particleCount = Math.min(count, this.maxParticles);
                this.particleSystem.geometry.setDrawRange(0, this.particleCount);
            }

            reset() {
                const active = this.particleSystem.geometry.attributes.active.array;
                for (let i = 0; i < this.maxParticles; i++) {
                    active[i] = 0;
                }
                this.particleSystem.geometry.attributes.active.needsUpdate = true;
            }

            setSize(size) {
                this.particleSystem.material.uniforms.size = { value: size };
            }

            pause() {
                this.isPaused = true;
            }

            resume() {
                this.isPaused = false;
            }
        }

        // Create particle system
        const particleSystem = new GPUParticleSystem();

        // Set initial system
        particleSystem.setSystem('fire');

        // Global functions for UI
        window.setParticleSystem = (systemName) => {
            particleSystem.setSystem(systemName);
            
            // Update button states
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        };

        window.resetParticles = () => {
            particleSystem.reset();
        };

        window.togglePause = () => {
            if (particleSystem.isPaused) {
                particleSystem.resume();
                event.target.textContent = 'Pause';
            } else {
                particleSystem.pause();
                event.target.textContent = 'Resume';
            }
        };

        // Control bindings
        const countSlider = document.getElementById('particle-count');
        const countDisplay = document.getElementById('count-val');
        countSlider.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            particleSystem.setParticleCount(count);
            countDisplay.textContent = count;
        });

        const sizeSlider = document.getElementById('particle-size');
        const sizeDisplay = document.getElementById('size-val');
        sizeSlider.addEventListener('input', (e) => {
            const size = parseFloat(e.target.value);
            particleSystem.setSize(size);
            sizeDisplay.textContent = size.toFixed(1);
        });

        const speedSlider = document.getElementById('sim-speed');
        const speedDisplay = document.getElementById('speed-val');
        speedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            particleSystem.simulationSpeed = speed;
            speedDisplay.textContent = speed.toFixed(1);
        });

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta() * (particleSystem.simulationSpeed || 1.0);

            particleSystem.update(deltaTime);

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
