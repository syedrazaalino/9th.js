<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bone Constraints Demo</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
        }
        .control-group { margin: 10px 0; }
        label { display: block; margin-bottom: 5px; }
        input[type="range"] { width: 100%; }
        button {
            margin: 2px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #666; }
        button.active { background: #007acc; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Bone Constraints Demo</strong><br>
        Animation constraints and IK system<br>
        - Inverse kinematics (IK)<br>
        - Bone rotation limits<br>
        - Target following<br>
        - Constraint visualization
    </div>
    
    <div id="controls">
        <div class="control-group">
            <button onclick="setConstraintMode('ik')" class="active">IK Chain</button>
            <button onclick="setConstraintMode('limit')">Rotation Limits</button>
            <button onclick="setConstraintMode('follow')">Target Follow</button>
            <button onclick="setConstraintMode('spring')">Spring Chain</button>
        </div>
        <div class="control-group">
            <label>Constraint Strength: <span id="strength-val">1.0</span></label>
            <input type="range" id="constraint-strength" min="0.1" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Chain Length: <span id="chain-val">8</span></label>
            <input type="range" id="chain-length" min="3" max="20" step="1" value="8">
        </div>
        <div class="control-group">
            <button onclick="resetChain()">Reset</button>
            <button onclick="randomizeTarget()">Random Target</button>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "../node_modules/three/build/three.module.js",
            "three/addons/": "../node_modules/three/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2c3e50);
        scene.fog = new THREE.Fog(0x2c3e50, 10, 50);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);
        camera.lookAt(0, 5, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 5, 0);
        controls.enableDamping = true;

        // Bone Constraint System
        class BoneConstraintSystem {
            constructor() {
                this.bones = [];
                this.target = null;
                this.currentMode = 'ik';
                this.chainLength = 8;
                this.constraintStrength = 1.0;
                this.iterations = 10;

                this.createChain();
                this.createTarget();
            }

            createChain() {
                // Create a chain of bones
                const boneGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
                const boneMaterial = new THREE.MeshLambertMaterial({ color: 0xe74c3c });

                for (let i = 0; i < this.chainLength; i++) {
                    const bone = new THREE.Mesh(boneGeometry, boneMaterial.clone());
                    bone.position.y = i * 1.2;
                    bone.castShadow = true;
                    bone.userData.index = i;
                    
                    // Add constraint visualization
                    if (i > 0) {
                        bone.userData.rotationLimits = {
                            min: new THREE.Euler(-Math.PI/2, -Math.PI/3, -Math.PI/3),
                            max: new THREE.Euler(Math.PI/2, Math.PI/3, Math.PI/3)
                        };
                    }
                    
                    scene.add(bone);
                    this.bones.push(bone);
                }

                // Create bone connections (lines)
                this.createBoneConnections();
            }

            createBoneConnections() {
                const points = [];
                for (let i = 0; i < this.bones.length - 1; i++) {
                    points.push(this.bones[i].position.clone());
                    points.push(this.bones[i + 1].position.clone());
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                this.boneLines = new THREE.LineSegments(
                    geometry,
                    new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 })
                );
                scene.add(this.boneLines);
            }

            createTarget() {
                const targetGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const targetMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.target = new THREE.Mesh(targetGeometry, targetMaterial);
                this.target.position.set(8, 8, 8);
                scene.add(this.target);
            }

            setConstraintMode(mode) {
                this.currentMode = mode;
            }

            setChainLength(length) {
                // Remove existing bones
                this.bones.forEach(bone => scene.remove(bone));
                scene.remove(this.boneLines);
                
                this.chainLength = length;
                this.bones = [];
                this.createChain();
            }

            solveIK() {
                const targetPos = this.target.position.clone();
                
                // CCD (Cyclic Coordinate Descent) algorithm
                for (let iter = 0; iter < this.iterations; iter++) {
                    for (let i = this.bones.length - 2; i >= 0; i--) {
                        const bone = this.bones[i];
                        const endEffector = this.bones[this.bones.length - 1];
                        
                        // Vector from bone to end effector
                        const toEnd = endEffector.position.clone().sub(bone.position);
                        
                        // Vector from bone to target
                        const toTarget = targetPos.clone().sub(bone.position);
                        
                        // Calculate rotation needed
                        const rotation = new THREE.Quaternion();
                        rotation.setFromUnitVectors(toEnd.normalize(), toTarget.normalize());
                        
                        // Apply rotation with constraint strength
                        rotation.slerp(new THREE.Quaternion(), 1 - this.constraintStrength);
                        bone.quaternion.multiply(rotation);
                        
                        // Apply rotation limits
                        this.applyRotationLimits(bone);
                    }
                }
            }

            applyRotationLimits(bone) {
                if (bone.userData.rotationLimits) {
                    const limits = bone.userData.rotationLimits;
                    const euler = new THREE.Euler().setFromQuaternion(bone.quaternion);
                    
                    // Clamp rotation within limits
                    euler.x = THREE.MathUtils.clamp(euler.x, limits.min.x, limits.max.x);
                    euler.y = THREE.MathUtils.clamp(euler.y, limits.min.y, limits.max.y);
                    euler.z = THREE.MathUtils.clamp(euler.z, limits.min.z, limits.max.z);
                    
                    bone.quaternion.setFromEuler(euler);
                }
            }

            solveFollow() {
                // Simple target following with constraints
                const targetPos = this.target.position.clone();
                
                for (let i = 1; i < this.bones.length; i++) {
                    const bone = this.bones[i];
                    const parent = this.bones[i - 1];
                    
                    // Point towards target
                    const direction = targetPos.clone().sub(bone.position).normalize();
                    const up = new THREE.Vector3(0, 1, 0);
                    const right = new THREE.Vector3().crossVectors(up, direction).normalize();
                    const adjustedUp = new THREE.Vector3().crossVectors(direction, right).normalize();
                    
                    const matrix = new THREE.Matrix4();
                    matrix.makeBasis(right, adjustedUp, direction);
                    
                    const targetQuat = new THREE.Quaternion().setFromRotationMatrix(matrix);
                    bone.quaternion.slerp(targetQuat, this.constraintStrength * 0.1);
                    
                    this.applyRotationLimits(bone);
                }
            }

            solveSpring() {
                // Spring-based constraints
                const targetPos = this.target.position.clone();
                const springStrength = this.constraintStrength * 0.1;
                
                for (let i = 1; i < this.bones.length; i++) {
                    const bone = this.bones[i];
                    
                    // Apply spring force towards target
                    const force = targetPos.clone().sub(bone.position).multiplyScalar(springStrength);
                    bone.position.add(force);
                    
                    // Apply rotation limits
                    this.applyRotationLimits(bone);
                }
            }

            update() {
                switch(this.currentMode) {
                    case 'ik':
                        this.solveIK();
                        break;
                    case 'follow':
                        this.solveFollow();
                        break;
                    case 'spring':
                        this.solveSpring();
                        break;
                    case 'limit':
                        // Just apply rotation limits
                        this.bones.forEach(bone => this.applyRotationLimits(bone));
                        break;
                }
                
                // Update bone connections
                this.updateBoneConnections();
            }

            updateBoneConnections() {
                const points = [];
                for (let i = 0; i < this.bones.length - 1; i++) {
                    points.push(this.bones[i].position.clone());
                    points.push(this.bones[i + 1].position.clone());
                }
                this.boneLines.geometry.setFromPoints(points);
            }

            reset() {
                // Reset bone positions
                for (let i = 0; i < this.bones.length; i++) {
                    const bone = this.bones[i];
                    bone.position.set(0, i * 1.2, 0);
                    bone.quaternion.identity();
                }
            }

            randomizeTarget() {
                const x = (Math.random() - 0.5) * 20;
                const y = Math.random() * 15 + 2;
                const z = (Math.random() - 0.5) * 20;
                this.target.position.set(x, y, z);
            }
        }

        // Create constraint system
        const constraintSystem = new BoneConstraintSystem();

        // Ground plane
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Global functions
        window.setConstraintMode = (mode) => {
            constraintSystem.setConstraintMode(mode);
            
            // Update button states
            document.querySelectorAll('button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        };

        window.resetChain = () => {
            constraintSystem.reset();
        };

        window.randomizeTarget = () => {
            constraintSystem.randomizeTarget();
        };

        // Control bindings
        const strengthSlider = document.getElementById('constraint-strength');
        const strengthDisplay = document.getElementById('strength-val');
        strengthSlider.addEventListener('input', (e) => {
            constraintSystem.constraintStrength = parseFloat(e.target.value);
            strengthDisplay.textContent = e.target.value;
        });

        const chainSlider = document.getElementById('chain-length');
        const chainDisplay = document.getElementById('chain-val');
        chainSlider.addEventListener('input', (e) => {
            const length = parseInt(e.target.value);
            constraintSystem.setChainLength(length);
            chainDisplay.textContent = length;
        });

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            constraintSystem.update();

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
