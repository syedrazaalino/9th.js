<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Instancing & Batch Rendering Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }
        
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 18px;
            text-align: center;
            max-width: 80%;
            z-index: 1001;
        }
        
        .hidden {
            display: none;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        
        #info h3 {
            margin: 0 0 10px 0;
            color: #00ffff;
        }
        
        #info p {
            margin: 5px 0;
        }
        
        #info .key {
            color: #ffff00;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">üöÄ Initializing GPU Instancing Demo...</div>
    <div id="error" class="hidden"></div>
    
    <div id="info">
        <h3>üéÆ Instancing Demo Controls</h3>
        <p><span class="key">P</span> - Performance Test (1000‚Üí50000 instances)</p>
        <p><span class="key">R</span> - Reset Demo</p>
        <p><span class="key">SPACE</span> - Show Status</p>
        <p><span class="key">L</span> - Toggle LOD</p>
        <p><span class="key">F</span> - Toggle Fullscreen</p>
        <p style="margin-top: 10px; color: #00ff00;">üí° Watch the stats panel for real-time performance!</p>
    </div>
    
    <script type="module">
        import { InstancingSystem, InstancingUtils } from '../src/rendering/Instancing.js';
        import { WebGLRenderer } from '../src/core/WebGLRenderer.js';
        import { Scene } from '../src/core/Scene.js';
        import { Camera } from '../src/core/Camera.js';
        import { Vector3 } from '../src/core/math/Vector3.js';
        
        /**
         * Simple instanced shader
         */
        class DemoShader {
            constructor(gl) {
                this.gl = gl;
                this.program = this._createProgram();
                this.isReady = true;
                this.id = 1;
            }

            _createProgram() {
                const gl = this.gl;
                
                const vertexShaderSource = `
                    attribute vec3 position;
                    attribute mat4 instanceMatrix;
                    uniform mat4 projectionMatrix;
                    uniform mat4 viewMatrix;
                    
                    varying vec3 vPosition;
                    
                    void main() {
                        vec4 worldPos = instanceMatrix * vec4(position, 1.0);
                        vPosition = worldPos.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPos;
                    }
                `;

                const fragmentShaderSource = `
                    precision mediump float;
                    varying vec3 vPosition;
                    uniform vec4 color;
                    uniform vec3 lightDir;
                    
                    void main() {
                        // Simple lighting
                        vec3 normal = normalize(vPosition);
                        float diffuse = max(dot(normal, normalize(lightDir)), 0.1);
                        vec3 finalColor = color.rgb * diffuse;
                        gl_FragColor = vec4(finalColor, color.a);
                    }
                `;

                const vertexShader = this._compileShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Program linking failed: ' + gl.getProgramInfoLog(program));
                }

                return program;
            }

            _compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compilation failed: ' + gl.getShaderInfoLog(shader));
                }

                return shader;
            }

            getProgram() {
                return this.program;
            }

            getId() {
                return this.id;
            }
        }

        /**
         * Main Demo Class
         */
        class InstancingDemo {
            constructor() {
                this.canvas = null;
                this.renderer = null;
                this.scene = null;
                this.camera = null;
                this.instances = null;
                this.shader = null;
                this.material = null;
                this.geometry = null;
                
                // Demo state
                this.isRunning = false;
                this.lastTime = 0;
                this.cameraAngle = 0;
                this.settings = {
                    instanceCount: 10000,
                    enableLOD: true,
                    showStats: true,
                    animateCamera: true
                };
            }

            async initialize() {
                this.canvas = document.getElementById('canvas');
                const loading = document.getElementById('loading');
                const error = document.getElementById('error');

                try {
                    // Create WebGL renderer
                    this.renderer = new WebGLRenderer(this.canvas, {
                        antialias: true,
                        alpha: false,
                        depth: true,
                        powerPreference: 'high-performance'
                    });

                    // Set initial size
                    this.renderer.setSize(window.innerWidth, window.innerHeight);

                    // Create scene and camera
                    this.scene = new Scene();
                    this.camera = new Camera();
                    this.camera.setPosition(0, 50, 200);
                    this.camera.lookAt(0, 0, 0);

                    // Create shader and material
                    this.shader = new DemoShader(this.renderer.gl);
                    this.material = {
                        color: [0.2, 0.8, 1.0, 1.0],
                        getId: () => 1
                    };

                    // Create geometry
                    this.geometry = InstancingUtils.createUnitCube(this.renderer.gl);

                    // Initialize instancing system
                    this.instances = new InstancingSystem(this.renderer.gl, {
                        maxInstances: 50000,
                        enableProfiling: true,
                        autoBatch: true,
                        enableLOD: this.settings.enableLOD,
                        debugMode: true
                    });

                    // Create demo instances
                    this._createInstances();

                    // Setup controls
                    this._setupControls();

                    // Hide loading, start demo
                    loading.classList.add('hidden');
                    this.isRunning = true;
                    this._animate();

                    console.log('‚úÖ Instancing demo initialized successfully');
                    console.log(`üéÆ Rendering ${this.settings.instanceCount.toLocaleString()} instances`);

                } catch (err) {
                    console.error('‚ùå Failed to initialize demo:', err);
                    loading.classList.add('hidden');
                    error.textContent = 'Failed to initialize WebGL instancing demo: ' + err.message;
                    error.classList.remove('hidden');
                }
            }

            _createInstances() {
                console.log(`üåü Creating ${this.settings.instanceCount.toLocaleString()} instances...`);
                
                // Generate distributed positions
                const positions = this._generateDistributedPositions(this.settings.instanceCount);

                const startTime = performance.now();

                // Create instances
                for (let i = 0; i < positions.length; i++) {
                    const [x, y, z] = positions[i];
                    
                    // Random scale with some variation
                    const baseScale = 0.8;
                    const scale = [
                        baseScale + Math.random() * 0.8,
                        baseScale + Math.random() * 0.8,
                        baseScale + Math.random() * 0.8
                    ];

                    // Create instance
                    this.instances.createInstance({
                        position: [x, y, z],
                        rotation: [0, 0, 0, 1],
                        scale: scale,
                        batchInfo: {
                            material: this.material,
                            geometry: this.geometry,
                            shader: this.shader
                        }
                    });
                }

                const endTime = performance.now();
                console.log(`‚ö° Instance creation time: ${(endTime - startTime).toFixed(2)}ms`);
            }

            _generateDistributedPositions(count) {
                const positions = [];
                const layers = Math.ceil(Math.sqrt(count / 100)); // Adjust layer count based on instance count
                const layerSize = Math.ceil(Math.sqrt(count / layers));
                
                for (let layer = 0; layer < layers && positions.length < count; layer++) {
                    const layerRadius = (layer + 1) * 20;
                    const layerCount = Math.min(layerSize * layerSize, count - positions.length);
                    
                    for (let i = 0; i < layerCount && positions.length < count; i++) {
                        const angle = (i / layerCount) * Math.PI * 2;
                        const x = Math.cos(angle) * layerRadius;
                        const z = Math.sin(angle) * layerRadius;
                        const y = (Math.random() - 0.5) * 10;
                        
                        positions.push([x, y, z]);
                    }
                }
                
                return positions;
            }

            _setupControls() {
                document.addEventListener('keydown', async (event) => {
                    switch (event.key.toLowerCase()) {
                        case 'p':
                            await this._runPerformanceTest();
                            break;
                        case 'r':
                            this._resetDemo();
                            break;
                        case ' ':
                            this._showStatus();
                            break;
                        case 'l':
                            this._toggleLOD();
                            break;
                        case 'f':
                            this._toggleFullscreen();
                            break;
                    }
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    if (this.renderer) {
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    }
                });
            }

            async _runPerformanceTest() {
                console.log('üèÉ Starting performance test...');
                
                const configs = [
                    { instances: 1000, name: 'Light Load (1K)' },
                    { instances: 5000, name: 'Medium Load (5K)' },
                    { instances: 10000, name: 'High Load (10K)' },
                    { instances: 25000, name: 'Very High Load (25K)' },
                    { instances: 50000, name: 'Extreme Load (50K)' }
                ];

                for (const config of configs) {
                    console.log(`\nüìä Testing ${config.name}...`);
                    
                    // Update settings
                    this.settings.instanceCount = config.instances;
                    this._resetDemo(false); // Don't log during performance test

                    // Measure performance
                    const frameCount = 30;
                    const frameTimes = [];

                    for (let i = 0; i < frameCount; i++) {
                        const start = performance.now();
                        
                        // Render frame
                        this._updateCamera(16.67); // Simulate 60fps
                        this.renderer.render(this.scene, this.camera);
                        this.instances.render(this.renderer, this.scene);
                        
                        const end = performance.now();
                        frameTimes.push(end - start);

                        // Small delay
                        await new Promise(resolve => setTimeout(resolve, 16));
                    }

                    const avgFrameTime = frameTimes.reduce((a, b) => a + b) / frameTimes.length;
                    const fps = 1000 / avgFrameTime;
                    const stats = this.instances.getStats();
                    const performance = this.instances.getPerformanceAnalysis();

                    console.log(`  ‚ö° Avg Frame Time: ${avgFrameTime.toFixed(2)}ms`);
                    console.log(`  üéØ Avg FPS: ${fps.toFixed(1)}`);
                    console.log(`  üì¶ Total Instances: ${config.instances.toLocaleString()}`);
                    console.log(`  üîÑ Draw Calls: ${performance ? performance.drawCalls : 'N/A'}`);
                    console.log(`  üìã Batches: ${performance ? performance.batches : 'N/A'}`);
                    console.log(`  ‚ö†Ô∏è  Warnings: ${performance ? performance.warnings.length : 0}`);
                    
                    // Pause between tests
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Reset to original
                this.settings.instanceCount = 10000;
                this._resetDemo();
                console.log('‚úÖ Performance test completed!');
            }

            _resetDemo(log = true) {
                if (log) console.log('üîÑ Resetting demo...');
                
                // Dispose current instances
                if (this.instances) {
                    this.instances.dispose();
                }

                // Recreate instancing system
                this.instances = new InstancingSystem(this.renderer.gl, {
                    maxInstances: 50000,
                    enableProfiling: true,
                    autoBatch: true,
                    enableLOD: this.settings.enableLOD,
                    debugMode: true
                });

                // Create new instances
                this._createInstances();
                
                if (log) console.log('‚ú® Demo reset complete!');
            }

            _showStatus() {
                const stats = this.instances.getStats();
                const performance = this.instances.getPerformanceAnalysis();
                
                console.log('\nüìä DEMO STATUS');
                console.log('===============');
                console.log(`Active Instances: ${stats.activeInstances.toLocaleString()}`);
                console.log(`Total Batches: ${stats.batchStats.totalBatches}`);
                console.log(`Draw Calls: ${stats.drawCalls}`);
                console.log(`Batching Efficiency: ${(stats.batchStats.batchingEfficiency * 100).toFixed(1)}%`);
                
                if (performance) {
                    console.log(`FPS: ${performance.fps.toFixed(1)}`);
                    console.log(`Frame Time: ${performance.frameTime.toFixed(2)}ms`);
                    console.log(`GPU Time: ${performance.gpuTime.toFixed(2)}ms`);
                    
                    if (performance.warnings.length > 0) {
                        console.log('\n‚ö†Ô∏è WARNINGS:');
                        performance.warnings.forEach(w => console.log(`  ‚Ä¢ ${w}`));
                    }
                    
                    if (performance.recommendations.length > 0) {
                        console.log('\nüí° RECOMMENDATIONS:');
                        performance.recommendations.forEach(r => console.log(`  ‚Ä¢ ${r}`));
                    }
                }
            }

            _toggleLOD() {
                this.settings.enableLOD = !this.settings.enableLOD;
                this.instances.options.enableLOD = this.settings.enableLOD;
                console.log(`üéöÔ∏è LOD ${this.settings.enableLOD ? 'enabled' : 'disabled'}`);
            }

            _toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            }

            _updateCamera(deltaTime) {
                if (!this.settings.animateCamera) return;

                this.cameraAngle += deltaTime * 0.001 * 0.5; // Slow orbit
                
                const radius = 200;
                const x = Math.cos(this.cameraAngle) * radius;
                const z = Math.sin(this.cameraAngle) * radius;
                const y = 50 + Math.sin(this.cameraAngle * 2) * 20;
                
                this.camera.setPosition(x, y, z);
                this.camera.lookAt(0, 0, 0);

                // Update LOD
                if (this.settings.enableLOD) {
                    this.instances.updateLOD(this.camera.getPosition());
                }
            }

            _animate(currentTime = 0) {
                if (!this.isRunning) return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                // Update camera animation
                this._updateCamera(deltaTime);

                // Render
                this.renderer.render(this.scene, this.camera);
                this.instances.render(this.renderer, this.scene);

                // Continue animation
                requestAnimationFrame((t) => this._animate(t));
            }
        }

        // Initialize demo
        const demo = new InstancingDemo();
        await demo.initialize();
    </script>
</body>
</html>